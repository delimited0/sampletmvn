#include "RcppArmadillo.h"
// [[Rcpp::depends(RcppArmadillo)]]

/*
 *  univariate rejection samplers
 */

const double a0 = 0.25696;

double unif_rej(double a, double b) {
  
  double u;
  double rho;
  double x;
  
  do {
    x = (b - a) * arma::randu() + a;
    u = arma::randu();
    
    if (a <= 0 && b >= 0) {
      rho = std::exp(-x*x / 2.);
    }
    if (a > 0) {
      rho = std::exp(-(x*x - a*a) / 2.);
    }
    if (b < 0) {
      rho = std::exp(-(x*x - b*b) / 2.);
    }
  } while (u > rho);
  
  return(x);
}

double norm_rej(double a, double b) {
  
  double x;
  
  do {
    x = arma::randn();
  } while (x < a || x > b);
  
  return(x);
}

double halfnorm_rej(double a, double b) {
  double x;
  do {
    x = arma::randn();
  } while (std::abs(x) < a || std::abs(x) > b);
  
  return(x);
} 

double exp_rej(double a, double b) {
  
  std::random_device rd;
  std::mt19937 gen(rd());
  std::weibull_distribution<> wd;
  double x;
  double u;
  double rho;
  double lambda = (a + std::sqrt(a*a + 4.) ) / 2;
  
  do {
    x = wd(gen);
    u = arma::randu();
    rho = std::exp(-std::pow((x - lambda), 2.) / 2);
  } while (u > rho || x >= b);
  
  return(x);
}

// [a, infty)
double rtuvn_case1(double a, double b) {
  double x;
  if (a < 0.) {
    x = norm_rej(a, b);
  }
  else {
    if (a < a0) {
      x = halfnorm_rej(a, b);
    }
    else {
      x = exp_rej(a, b);
    }
  }
  return(x);
}

// [a, b]
double rtuvn_case2(double a, double b) {
  double x;
  if (b > (std::sqrt(2*arma::datum::pi) + a)) {
    x = norm_rej(a, b);
  }
  else {
    x = unif_rej(a, b);
  }
  return(x);
}

// [a, b], a >= 0
double rtuvn_case3(double a, double b) {
  double x;
  if (a <= a0) {
    if (b <= (std::sqrt(arma::datum::pi / 2.) * std::exp(a*a / 2.) + a) ) {
      x = unif_rej(a, b);
    }
    else {
      x = halfnorm_rej(a, b);
    }
  }
  else {
    if (b <= (std::sqrt(2. * arma::datum::pi) + a) ) {
      x = unif_rej(a, b);
    }
    else {
      x = exp_rej(a, b);
    }
  }
  
  return(x);
}

/*
 * sample from univariate truncated normal
 * n number of samples
 * mean mean of the underlying univariate normal distribution.
 * sd standard deviation of the underlying univariate normal distribution.
 * a standardized lower bound
 * b standardized upper bound
 */
// [[Rcpp::export]]
arma::vec rtuvn(int n, double mean, double sd, double lower, double upper) {
  double x;
  
  double a = (lower - mean) / sd;
  double b = (upper - mean) / sd;
  
  arma::vec samples(n);
  
  for (int i = 0; i < n; i++) {
   
    if (std::isinf(a) || std::isinf(b)) {
      if (std::isinf(b)) {
        x = rtuvn_case1(a, b);
      }
      else {
        x = -rtuvn_case1(-b, -a);    
      }
    }
    else {
      if (a < 0 && b > 0) {
        x = rtuvn_case2(a, b);
      }
      if (a >= 0) {
        x = rtuvn_case3(a, b);
      }
      if (b <= 0) {
        x = -rtuvn_case3(-b, -a);
      }  
    }
    
    samples(i) = x;
  }
  
  samples = sd * samples + mean;

  return(samples);
}


